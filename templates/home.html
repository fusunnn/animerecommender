<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Anime Recommender</title>
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='css/home.css') }}"
    />
  </head>

  <body class="homeBody">
    <h1 class="animeSearchInputLabel">enter an anime :</h1>
    <form action="#" method="post" id="createReport" autocomplete="off">
      <input
        spellcheck="false"
        id="animeSearchInput"
        class="animeSearchInput"
        type="text"
        name="animeChoice"
        placeholder="naruto..."
      />
      <div class="autocompleteContainer" id="autocompleteContainer">
        <ul
          id="autocompleteListContainer"
          class="autocompleteListContainer hidden"
        ></ul>
      </div>
    </form>
    <h2 class="numberOfRecsLabel">how many recs?</h2>
    <div class="numberOfRecsContainer">
      <button
        type="button"
        onclick="incrementDown()"
        id="incrementDown"
        class="button incrementButton"
      >
        <p class="incrementButtonText">-</p>
      </button>

      <p class="numberOfRecsText standard-color" id="number">0</p>
      <button
        type="button"
        onclick="incrementUp()"
        id="incrementUp"
        class="button incrementButton"
      >
        <p class="incrementButtonText">+</p>
      </button>
    </div>
    <button
      type="submit"
      id="submitButton"
      form="createReport"
      class="button submitButton"
    >
      submit
    </button>
    <input
      name="howMany"
      form="createReport"
      id="howMany"
      class="hiddenNumber"
      value="0"
    />
  </body>

  <script>
    //getting the elements which will be modified through their ID to simplify the reading of code later on
    const animeSearchInput = document.getElementById("animeSearchInput");
    const autocompleteContainer = document.getElementById(
      "autocompleteContainer"
    );
    const autocompleteListContainer = document.getElementById(
      "autocompleteListContainer"
    );
    const numberOfRecs = document.getElementById("number");
    const submitButton = document.getElementById("submitButton");

    //functions which handle the clicking of the + and - buttons to increment the number of animes they get back
    function incrementUp() {
      if (![...numberOfRecs.classList].includes("white")) {
        numberOfRecs.classList.remove("standard-color");
        numberOfRecs.classList.add("white");
      }
      let newValue = parseInt(numberOfRecs.innerText) + 1;
      numberOfRecs.innerHTML = newValue;
      document.getElementById("howMany").value = parseInt(
        numberOfRecs.innerText
      );
    }

    function incrementDown() {
      if (parseInt(numberOfRecs.innerText) > 0) {
        numberOfRecs.innerHTML = parseInt(numberOfRecs.innerText) - 1;
        document.getElementById("howMany").value = parseInt(
          numberOfRecs.innerText
        );
      }
      if (parseInt(numberOfRecs.innerText) === 0) {
        numberOfRecs.classList.add("standard-color");
        numberOfRecs.classList.remove("white");
      }
    }
    //end of incrementation functions

    //function to autocomplete the value of an element in the animeSearchInput when one of the autocomplete elements is clicked
    //takes in the name of the anime that has been clicked on
    function autocompleteAnimeSearchInputValue(clickedOnAnime) {
      animeSearchInput.value = clickedOnAnime;
      autocompleteListContainer.classList.add("hidden");
    }

    //this is the function that generates all the autocompletes
    //first it fetches the autocomplete anime using the kitsu api, passing the current value of the animeSearchInput as the query arg
    //then it loops through and gets the necessary info
    //finally it creates a list element for each anime and adds it to the autocomplete container
    function fetchAutocompleteHandler() {
      //this is just to reset the autocoomplete list so that the lists don't accumulate
      //--> it resets and adds the new autocomplete elements everytime the user types
      autocompleteListContainer.innerHTML = "";
      //check to add or remove the hidden class
      //--> if the animeSearchInput is empty it will add a hidden class to the list container
      //so that there is not just a random empty box when the animeSearchInput is empty
      if (animeSearchInput.value != "") {
        autocompleteListContainer.classList.remove("hidden");
      } else {
        autocompleteListContainer.classList.add("hidden");
      }

      //fetch request to get the autocomplete elements --> fetched in our database's api
      fetch(
        "https://kitsu.io/api/edge/anime?filter[text]=" + animeSearchInput.value
      )
        .then((res) => {
          return res.json();
        })
        .then((result) => {
          //looping through the results of the fetch request and storing the information needed for the autocomplete
          var autocompleteElements = [];

          for (let i = 0; i < result.data.length; i++) {
            const resultTitle = result.data[i]["attributes"]["canonicalTitle"];
            const resultImagePath =
              result.data[i]["attributes"]["posterImage"]["tiny"];

            autocompleteElements.push([
              { title: resultTitle, image: resultImagePath },
            ]);
          }

          //looping through the stored information and creating a list element with the title and the image for the autocomplete
          for (let i = 0; i < autocompleteElements.length; i++) {
            const autocompleteElementContainer = document.createElement("li");
            autocompleteElementContainer.setAttribute(
              "class",
              "autocompleteElementContainer " +
                autocompleteElements[i][0]["title"]
            );

            autocompleteElementContainer.addEventListener("click", () => {
              autocompleteAnimeSearchInputValue(
                autocompleteElements[i][0]["title"]
              );
            });

            autocompleteElementContainer.innerHTML =
              autocompleteElements[i][0]["title"] +
              "<img class='autocompleteElementImage' src='" +
              autocompleteElements[i][0]["image"] +
              "' />";

            autocompleteListContainer.appendChild(autocompleteElementContainer);
          }
        });
    }

    //there is a timeout before the autocomplete pops up to avoid a bug which occurs when the user input is too quick
    //--> the autocomplet items don't update properly, and the autocomplete list accumulates if the user input is too fast
    //hence the timeout, which waits for the user to stop typing for 300 milliseconds to run the autocomplete suggestions
    let timeout = null;
    animeSearchInput.addEventListener("keyup", function () {
      clearTimeout(timeout);

      timeout = setTimeout(() => fetchAutocompleteHandler(), 300);
    });
  </script>
</html>
